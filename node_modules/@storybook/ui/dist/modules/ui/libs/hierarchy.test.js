"use strict";

require("core-js/modules/es6.array.map");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.string.iterator");

require("core-js/modules/es6.map");

var _hierarchy = require("./hierarchy");

describe('manager.ui.libs.hierarchy', function () {
  describe('createHierarchyRoot', function () {
    test('should return root hierarchy node', function () {
      var result = (0, _hierarchy.createHierarchyRoot)();
      expect(result).toEqual({
        namespaces: [],
        name: '',
        isNamespace: true,
        map: new Map()
      });
    });
    test('should return root hierarchy node with root name', function () {
      var result = (0, _hierarchy.createHierarchyRoot)('root name');
      expect(result).toEqual({
        namespaces: [],
        name: 'root name',
        isNamespace: true,
        map: new Map()
      });
    });
  });
  describe('createHierarchies', function () {
    test('should return empty root hierarchy if stories are undefined', function () {
      var result = (0, _hierarchy.createHierarchies)();
      expect(result[0]).toEqual({
        namespaces: [],
        name: '',
        isNamespace: true,
        map: new Map()
      });
    });
    test('should return empty root hierarchy if stories are empty', function () {
      var result = (0, _hierarchy.createHierarchies)([]);
      expect(result[0]).toEqual({
        namespaces: [],
        name: '',
        isNamespace: true,
        map: new Map()
      });
    });
    test('should return flat hierarchy if kind is not separated', function () {
      var stories = [{
        kind: 'some.name.item1',
        namespaces: ['some.name.item1'],
        stories: ['a1', 'a2']
      }, {
        kind: 'another.space.20',
        namespaces: ['another.space.20'],
        stories: ['b1', 'b2']
      }];
      var result = (0, _hierarchy.createHierarchies)(stories);
      var expected = [['some.name.item1', {
        kind: 'some.name.item1',
        name: 'some.name.item1',
        namespaces: ['some.name.item1'],
        highlight: null,
        isNamespace: true,
        map: new Map(),
        stories: [{
          name: 'a1',
          highlight: null
        }, {
          name: 'a2',
          highlight: null
        }]
      }], ['another.space.20', {
        kind: 'another.space.20',
        name: 'another.space.20',
        namespaces: ['another.space.20'],
        highlight: null,
        isNamespace: true,
        map: new Map(),
        stories: [{
          name: 'b1',
          highlight: null
        }, {
          name: 'b2',
          highlight: null
        }]
      }]];
      expect(result).toHaveLength(1);
      expect(result[0].map).toEqual(new Map(expected));
    });
    test('should return hierarchy if kind is separated', function () {
      var stories = [{
        kind: 'some.name.item1',
        namespaces: ['some', 'name', 'item1'],
        stories: ['a1', 'a2']
      }, {
        kind: 'another.space.20',
        namespaces: ['another', 'space', '20'],
        stories: ['b1', 'b2']
      }];
      var result = (0, _hierarchy.createHierarchies)(stories, '\\.');
      var expected = new Map([['some', {
        name: 'some',
        isNamespace: true,
        highlight: null,
        namespaces: ['some'],
        map: new Map([['name', {
          name: 'name',
          isNamespace: true,
          highlight: null,
          namespaces: ['some', 'name'],
          map: new Map([['item1', {
            kind: 'some.name.item1',
            name: 'item1',
            namespaces: ['some', 'name', 'item1'],
            isNamespace: true,
            highlight: null,
            map: new Map(),
            stories: [{
              name: 'a1',
              highlight: null
            }, {
              name: 'a2',
              highlight: null
            }]
          }]])
        }]])
      }], ['another', {
        name: 'another',
        isNamespace: true,
        highlight: null,
        namespaces: ['another'],
        map: new Map([['space', {
          name: 'space',
          isNamespace: true,
          highlight: null,
          namespaces: ['another', 'space'],
          map: new Map([['20', {
            kind: 'another.space.20',
            name: '20',
            namespaces: ['another', 'space', '20'],
            isNamespace: true,
            highlight: null,
            map: new Map(),
            stories: [{
              name: 'b1',
              highlight: null
            }, {
              name: 'b2',
              highlight: null
            }]
          }]])
        }]])
      }]]);
      expect(result).toHaveLength(1);
      expect(result[0].map).toEqual(expected);
    });
    test('should return multiple roots with main root first when different root names are given', function () {
      var stories = [{
        kind: 'second|some.name.item1',
        rootName: 'second',
        namespaces: ['some.name.item1'],
        stories: ['a1', 'a2']
      }, {
        kind: 'another.space.20',
        rootName: '',
        // main
        namespaces: ['another.space.20'],
        stories: ['b1', 'b2']
      }];
      var result = (0, _hierarchy.createHierarchies)(stories);
      var expectedMain = [['another.space.20', {
        kind: 'another.space.20',
        name: 'another.space.20',
        namespaces: ['another.space.20'],
        highlight: null,
        isNamespace: true,
        map: new Map(),
        stories: [{
          name: 'b1',
          highlight: null
        }, {
          name: 'b2',
          highlight: null
        }]
      }]];
      var expectedSecond = [['some.name.item1', {
        kind: 'second|some.name.item1',
        name: 'some.name.item1',
        namespaces: ['some.name.item1'],
        highlight: null,
        isNamespace: true,
        map: new Map(),
        stories: [{
          name: 'a1',
          highlight: null
        }, {
          name: 'a2',
          highlight: null
        }]
      }]];
      expect(result).toHaveLength(2);
      expect(result[0].map).toEqual(new Map(expectedMain));
      expect(result[1].map).toEqual(new Map(expectedSecond));
    });
  });
  describe('resolveStoryHierarchy', function () {
    test('should return array with initial namespace when hierarchySeparator is undefined', function () {
      var result = (0, _hierarchy.resolveStoryHierarchy)('some.name.item1');
      expect(result).toEqual(['some.name.item1']);
    });
    test('should return array with separated namespaces when hierarchySeparator is defined', function () {
      var result = (0, _hierarchy.resolveStoryHierarchy)('some/name.item1', '\\.|\\/');
      expect(result).toEqual(['some', 'name', 'item1']);
    });
  });
  describe('resolveStoryHierarchyRoots', function () {
    test('should return empty root name when hierarchyRootSeparator is undefined', function () {
      var _resolveStoryHierarch = (0, _hierarchy.resolveStoryHierarchyRoots)('some|name.item1'),
          rootName = _resolveStoryHierarch.rootName,
          storyName = _resolveStoryHierarch.storyName;

      expect(rootName).toEqual('');
      expect(storyName).toEqual('some|name.item1');
    });
    test('should return array with separated root name and story name when hierarchyRootSeparator is defined', function () {
      var _resolveStoryHierarch2 = (0, _hierarchy.resolveStoryHierarchyRoots)('some|name.item1', '\\|'),
          rootName = _resolveStoryHierarch2.rootName,
          storyName = _resolveStoryHierarch2.storyName;

      expect(rootName).toEqual('some');
      expect(storyName).toEqual('name.item1');
    });
    test('should throw error when hierarchyRootSeparator is found multiple times', function () {
      expect(function () {
        (0, _hierarchy.resolveStoryHierarchyRoots)('some|name|item1', '\\|');
      }).toThrow();
    });
  });
  describe('prepareStoriesForHierarchy', function () {
    test('should return null when nothing provided', function () {
      var result = (0, _hierarchy.prepareStoriesForHierarchy)();
      expect(result).toBe(null);
    });
    test('should return kind in namespaces when separator is not provided', function () {
      var stories = [{
        kind: 'some.name.item1'
      }, {
        kind: 'another.space.20'
      }];
      var result = (0, _hierarchy.prepareStoriesForHierarchy)(stories);
      expect(result).toEqual([{
        kind: 'some.name.item1',
        namespaces: ['some.name.item1'],
        rootName: ''
      }, {
        kind: 'another.space.20',
        namespaces: ['another.space.20'],
        rootName: ''
      }]);
    });
    test('should return separated namespaces when separator is provided', function () {
      var stories = [{
        kind: 'some.name.item1'
      }, {
        kind: 'another.space.20'
      }];
      var result = (0, _hierarchy.prepareStoriesForHierarchy)(stories, '\\.');
      expect(result).toEqual([{
        kind: 'some.name.item1',
        namespaces: ['some', 'name', 'item1'],
        rootName: ''
      }, {
        kind: 'another.space.20',
        namespaces: ['another', 'space', '20'],
        rootName: ''
      }]);
    });
    test('should return filled root name when root separator is provided', function () {
      var stories = [{
        kind: 'some.name.item1'
      }, {
        kind: 'another|space.20'
      }];
      var result = (0, _hierarchy.prepareStoriesForHierarchy)(stories, '\\.', '\\|');
      expect(result).toEqual([{
        kind: 'some.name.item1',
        namespaces: ['some', 'name', 'item1'],
        rootName: ''
      }, {
        kind: 'another|space.20',
        namespaces: ['space', '20'],
        rootName: 'another'
      }]);
    });
  });
});