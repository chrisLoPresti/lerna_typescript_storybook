"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHierarchyRoot = createHierarchyRoot;
exports.createHierarchies = createHierarchies;
exports.resolveStoryHierarchyRoots = resolveStoryHierarchyRoots;
exports.resolveStoryHierarchy = resolveStoryHierarchy;
exports.prepareStoriesForHierarchy = prepareStoriesForHierarchy;

require("core-js/modules/es6.object.keys");

require("core-js/modules/es6.object.define-property");

require("core-js/modules/es6.array.from");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.array.is-array");

require("core-js/modules/es6.regexp.constructor");

require("core-js/modules/es6.regexp.split");

require("core-js/modules/es7.object.values");

require("core-js/modules/es6.array.for-each");

require("core-js/modules/es6.array.index-of");

require("core-js/modules/es6.function.name");

require("core-js/modules/es6.array.map");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.string.iterator");

require("core-js/modules/es6.map");

require("core-js/modules/es6.array.filter");

require("core-js/modules/es6.array.find");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function findMatches(matches, type, value) {
  if (!matches) {
    return null;
  }

  var matchForType = matches.filter(function (match) {
    return match.key === type;
  }).find(function (match) {
    return match.value === value;
  });

  if (!matchForType) {
    return null;
  }

  return matchForType.indices;
}

function createNamespaceNode(namespace, hierarchy, story) {
  return {
    isNamespace: true,
    name: namespace,
    namespaces: _toConsumableArray(hierarchy.namespaces).concat([namespace]),
    highlight: findMatches(story.matches, 'namespaces', namespace),
    map: new Map()
  };
}

function fillHierarchy(namespaces, hierarchy, story) {
  var namespace = namespaces[0];
  var childHierarchy = hierarchy.map.get(namespace);

  if (!childHierarchy) {
    childHierarchy = createNamespaceNode(namespace, hierarchy, story);
    hierarchy.map.set(namespace, childHierarchy);
  }

  if (namespaces.length === 1) {
    childHierarchy.kind = story.kind;
    childHierarchy.stories = story.stories.map(function (s) {
      return {
        name: s,
        highlight: findMatches(story.matches, 'stories', s)
      };
    });
    return;
  }

  fillHierarchy(namespaces.slice(1), childHierarchy, story);
}

function createHierarchyRoot() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    isNamespace: true,
    namespaces: [],
    name: name,
    map: new Map()
  };
}

function ensureMainRootIsFirst(hierarchies) {
  var mainRoot = hierarchies.find(function (hierarchy) {
    return hierarchy.name === '';
  });
  var mainRootIndex = hierarchies.indexOf(mainRoot);

  if (mainRootIndex === -1 && hierarchies.length === 0) {
    hierarchies.push(createHierarchyRoot());
  } else if (mainRootIndex > 0) {
    hierarchies.unshift.apply(hierarchies, _toConsumableArray(hierarchies.splice(mainRootIndex, 1)));
  }

  return hierarchies;
}

function createHierarchies(stories) {
  var rootMap = {};

  if (stories) {
    stories.forEach(function (story) {
      var _story$rootName = story.rootName,
          rootName = _story$rootName === void 0 ? '' : _story$rootName,
          namespaces = story.namespaces;
      var name = namespaces[namespaces.length - 1];
      var hierarchyRoot = rootMap[rootName] || (rootMap[rootName] = createHierarchyRoot(rootName));
      fillHierarchy(namespaces, hierarchyRoot, _objectSpread({}, story, {
        name: name
      }));
    });
  }

  return ensureMainRootIsFirst(Object.values(rootMap));
}

function resolveStoryHierarchyRoots() {
  var storyName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var hierarchyRootSeparator = arguments.length > 1 ? arguments[1] : undefined;

  if (!hierarchyRootSeparator) {
    return {
      rootName: '',
      storyName: storyName
    };
  }

  var segments = storyName.split(new RegExp(hierarchyRootSeparator));

  switch (segments.length) {
    case 1:
      return {
        rootName: '',
        storyName: storyName
      };

    case 2:
      return {
        rootName: segments[0],
        storyName: segments[1]
      };

    default:
      throw new Error("multiple root separators found in story name: ".concat(storyName));
  }
}

function resolveStoryHierarchy() {
  var storyName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var hierarchySeparator = arguments.length > 1 ? arguments[1] : undefined;

  if (!hierarchySeparator) {
    return [storyName];
  }

  return storyName.split(new RegExp(hierarchySeparator)).filter(function (segment) {
    return !!segment;
  });
}

function prepareStoriesForHierarchy(stories, hierarchySeparator, hierarchyRootSeparator) {
  if (!stories) {
    return null;
  }

  return stories.map(function (story) {
    var _resolveStoryHierarch = resolveStoryHierarchyRoots(story.kind, hierarchyRootSeparator),
        rootName = _resolveStoryHierarch.rootName,
        storyName = _resolveStoryHierarch.storyName;

    var namespaces = resolveStoryHierarchy(storyName, hierarchySeparator);
    return _objectSpread({}, story, {
      rootName: rootName,
      namespaces: namespaces
    });
  });
}