"use strict";

require("core-js/modules/es6.object.define-property");

var _shortcuts = _interopRequireDefault(require("./shortcuts"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MockClientStore =
/*#__PURE__*/
function () {
  function MockClientStore() {
    _classCallCheck(this, MockClientStore);
  }

  _createClass(MockClientStore, [{
    key: "update",
    value: function update(cb) {
      this.updateCallback = cb;
    }
  }]);

  return MockClientStore;
}();

describe('manager.shortcuts.actions.shortcuts', function () {
  describe('setOptions', function () {
    test('should update options', function () {
      var clientStore = new MockClientStore();

      _shortcuts.default.setOptions({
        clientStore: clientStore
      }, {
        goFullScreen: true
      });

      var stateUpdates = clientStore.updateCallback({});
      expect(stateUpdates.shortcutOptions).toMatchObject({
        goFullScreen: true
      });
    });
    test('should only update options for the key already defined', function () {
      var clientStore = new MockClientStore();

      _shortcuts.default.setOptions({
        clientStore: clientStore
      }, {
        goFullScreen: true,
        random: 'value'
      });

      var stateUpdates = clientStore.updateCallback({});
      expect(stateUpdates.shortcutOptions).toMatchObject({
        goFullScreen: true
      });
      expect(stateUpdates.shortcutOptions).not.toMatchObject({
        random: 'value'
      });
    });
    test('should warn about deprecated option names', function () {
      var clientStore = new MockClientStore();
      var spy = jest.spyOn(console, 'warn').mockImplementation(function () {});

      _shortcuts.default.setOptions({
        clientStore: clientStore
      }, {
        showLeftPanel: 1,
        showDownPanel: 2,
        downPanelInRight: 3
      });

      var stateUpdates = clientStore.updateCallback({});
      expect(spy).toHaveBeenCalledTimes(3);
      expect(stateUpdates.shortcutOptions).toMatchObject({
        showStoriesPanel: 1,
        showAddonPanel: 2,
        addonPanelInRight: 3
      });
      spy.mockReset();
      spy.mockRestore();
    });
  });
});