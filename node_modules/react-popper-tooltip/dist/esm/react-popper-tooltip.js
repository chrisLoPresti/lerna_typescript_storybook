import _extends from '@babel/runtime/helpers/esm/extends';
import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';
import React, { Component } from 'react';
import { findDOMNode, createPortal } from 'react-dom';
import { Popper, Manager, Reference } from 'react-popper';
import _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';

var TooltipContext = React.createContext({});
var callAll = function callAll() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fns.forEach(function (fn) {
      return fn && fn.apply(void 0, args);
    });
  };
};
var noop = function noop() {};
var canUseDOM = function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
};

var MUTATION_OBSERVER_CONFIG = {
  childList: true,
  subtree: true
};

var Tooltip =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Tooltip, _Component);

  function Tooltip() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.observer = void 0;

    _this.handleOutsideClick = function (event) {
      if (!findDOMNode(_assertThisInitialized(_assertThisInitialized(_this))).contains(event.target)) {
        var _this$props = _this.props,
            hideTooltip = _this$props.hideTooltip,
            clearScheduled = _this$props.clearScheduled,
            parentOutsideClickHandler = _this$props.parentOutsideClickHandler;
        clearScheduled();
        hideTooltip();

        if (parentOutsideClickHandler) {
          parentOutsideClickHandler(event);
        }
      }
    };

    _this.handleOutsideRightClick = function (event) {
      if (!findDOMNode(_assertThisInitialized(_assertThisInitialized(_this))).contains(event.target)) {
        var _this$props2 = _this.props,
            hideTooltip = _this$props2.hideTooltip,
            clearScheduled = _this$props2.clearScheduled,
            parentOutsideRightClickHandler = _this$props2.parentOutsideRightClickHandler;
        clearScheduled();
        hideTooltip();

        if (parentOutsideRightClickHandler) {
          parentOutsideRightClickHandler(event);
        }
      }
    };

    _this.addOutsideClickHandler = function () {
      if ('ontouchend' in window) {
        document.addEventListener('touchend', _this.handleOutsideClick);
      } else {
        document.addEventListener('click', _this.handleOutsideClick);
      }
    };

    _this.removeOutsideClickHandler = function () {
      document.removeEventListener('touchend', _this.handleOutsideClick);
      document.removeEventListener('click', _this.handleOutsideClick);
    };

    _this.addOutsideRightClickHandler = function () {
      return document.addEventListener('contextmenu', _this.handleOutsideRightClick);
    };

    _this.removeOutsideRightClickHandler = function () {
      return document.removeEventListener('contextmenu', _this.handleOutsideRightClick);
    };

    _this.getArrowProps = function (props) {
      if (props === void 0) {
        props = {};
      }

      return _extends({}, props, {
        style: _extends({}, props.style, _this.props.arrowProps.style)
      });
    };

    _this.getTooltipProps = function (props) {
      if (props === void 0) {
        props = {};
      }

      var isHoverTriggered = _this.props.trigger === 'hover';
      return _extends({}, props, isHoverTriggered && {
        onMouseEnter: callAll(_this.props.clearScheduled, props.onMouseEnter)
      }, isHoverTriggered && {
        onMouseLeave: callAll(_this.props.hideTooltip, props.onMouseLeave)
      }, {
        style: _extends({}, props.style, _this.props.style)
      });
    };

    return _this;
  }

  var _proto = Tooltip.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var trigger = this.props.trigger;
    var observer = this.observer = new MutationObserver(function () {
      _this2.props.scheduleUpdate();
    });
    observer.observe(findDOMNode(this), MUTATION_OBSERVER_CONFIG);

    if (trigger === 'click' || trigger === 'right-click') {
      var _this$props3 = this.props,
          removeParentOutsideClickHandler = _this$props3.removeParentOutsideClickHandler,
          removeParentOutsideRightClickHandler = _this$props3.removeParentOutsideRightClickHandler;
      this.addOutsideClickHandler();
      this.addOutsideRightClickHandler();

      if (removeParentOutsideClickHandler) {
        removeParentOutsideClickHandler();
      }

      if (removeParentOutsideRightClickHandler) {
        removeParentOutsideRightClickHandler();
      }
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    if (this.props.closeOnOutOfBoundaries && this.props.outOfBoundaries) {
      this.props.hideTooltip();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var trigger = this.props.trigger;

    if (this.observer) {
      this.observer.disconnect();
    }

    if (trigger === 'click' || trigger === 'right-click') {
      var _this$props4 = this.props,
          addParentOutsideClickHandler = _this$props4.addParentOutsideClickHandler,
          addParentOutsideRightClickHandler = _this$props4.addParentOutsideRightClickHandler;
      this.removeOutsideClickHandler();
      this.removeOutsideRightClickHandler();
      this.handleOutsideClick = undefined;
      this.handleOutsideRightClick = undefined;

      if (addParentOutsideClickHandler) {
        addParentOutsideClickHandler();
      }

      if (addParentOutsideRightClickHandler) {
        addParentOutsideRightClickHandler();
      }
    }
  };

  _proto.render = function render() {
    var _this$props5 = this.props,
        arrowProps = _this$props5.arrowProps,
        placement = _this$props5.placement,
        tooltip = _this$props5.tooltip,
        innerRef = _this$props5.innerRef;
    return React.createElement(TooltipContext.Provider, {
      value: {
        addParentOutsideClickHandler: this.addOutsideClickHandler,
        addParentOutsideRightClickHandler: this.addOutsideRightClickHandler,
        parentOutsideClickHandler: this.handleOutsideClick,
        parentOutsideRightClickHandler: this.handleOutsideRightClick,
        removeParentOutsideClickHandler: this.removeOutsideClickHandler,
        removeParentOutsideRightClickHandler: this.removeOutsideRightClickHandler
      }
    }, tooltip({
      arrowRef: arrowProps.ref,
      getArrowProps: this.getArrowProps,
      getTooltipProps: this.getTooltipProps,
      placement: placement,
      tooltipRef: innerRef
    }));
  };

  return Tooltip;
}(Component);

var DEFAULT_MODIFIERS = {
  preventOverflow: {
    boundariesElement: 'viewport'
  }
};

var TooltipTrigger =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(TooltipTrigger, _Component);

  function TooltipTrigger() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      tooltipShown: _this.props.defaultTooltipShown
    };
    _this.hideTimeout = void 0;
    _this.showTimeout = void 0;

    _this.setTooltipState = function (state) {
      var cb = function cb() {
        return _this.props.onVisibilityChange(state.tooltipShown);
      };

      _this.isControlled() ? cb() : _this.setState(state, cb);
    };

    _this.clearScheduled = function () {
      clearTimeout(_this.hideTimeout);
      clearTimeout(_this.showTimeout);
    };

    _this.showTooltip = function (_ref) {
      var pageX = _ref.pageX,
          pageY = _ref.pageY;

      _this.clearScheduled();

      var state = {
        tooltipShown: true
      };

      if (_this.props.followCursor) {
        state = _extends({}, state, {
          pageX: pageX,
          pageY: pageY
        });
      }

      _this.showTimeout = window.setTimeout(function () {
        return _this.setTooltipState(state);
      }, _this.props.delayShow);
    };

    _this.hideTooltip = function () {
      _this.clearScheduled();

      _this.hideTimeout = window.setTimeout(function () {
        return _this.setTooltipState({
          tooltipShown: false
        });
      }, _this.props.delayHide);
    };

    _this.toggleTooltip = function (_ref2) {
      var pageX = _ref2.pageX,
          pageY = _ref2.pageY;
      var action = _this.getState() ? 'hideTooltip' : 'showTooltip';

      _this[action]({
        pageX: pageX,
        pageY: pageY
      });
    };

    _this.clickToggle = function (_ref3) {
      var pageX = _ref3.pageX,
          pageY = _ref3.pageY;
      var action = _this.props.followCursor ? 'showTooltip' : 'toggleTooltip';

      _this[action]({
        pageX: pageX,
        pageY: pageY
      });
    };

    _this.contextMenuToggle = function (event) {
      event.preventDefault();
      var pageX = event.pageX,
          pageY = event.pageY;
      var action = _this.props.followCursor ? 'showTooltip' : 'toggleTooltip';

      _this[action]({
        pageX: pageX,
        pageY: pageY
      });
    };

    _this.getTriggerProps = function (props) {
      if (props === void 0) {
        props = {};
      }

      var _this$props = _this.props,
          trigger = _this$props.trigger,
          followCursor = _this$props.followCursor;
      var isClickTriggered = trigger === 'click';
      var isHoverTriggered = trigger === 'hover';
      var isRightClickTriggered = trigger === 'right-click';
      var isTouchEnabled = canUseDOM() && 'ontouchend' in window;
      return _extends({}, props, isClickTriggered && isTouchEnabled && {
        onTouchEnd: callAll(_this.clickToggle, props.onTouchEnd)
      }, isClickTriggered && !isTouchEnabled && {
        onClick: callAll(_this.clickToggle, props.onClick)
      }, isRightClickTriggered && {
        onContextMenu: callAll(_this.contextMenuToggle, props.onContextMenu)
      }, isHoverTriggered && {
        onMouseEnter: callAll(_this.showTooltip, props.onMouseEnter)
      }, isHoverTriggered && {
        onMouseLeave: callAll(_this.hideTooltip, props.onMouseLeave)
      }, isHoverTriggered && followCursor && {
        onMouseMove: callAll(_this.showTooltip, props.onMouseMove)
      });
    };

    return _this;
  }

  var _proto = TooltipTrigger.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.clearScheduled();
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        children = _this$props2.children,
        tooltip = _this$props2.tooltip,
        placement = _this$props2.placement,
        trigger = _this$props2.trigger,
        getTriggerRef = _this$props2.getTriggerRef,
        modifiers = _this$props2.modifiers,
        closeOnOutOfBoundaries = _this$props2.closeOnOutOfBoundaries,
        usePortal = _this$props2.usePortal,
        portalContainer = _this$props2.portalContainer,
        followCursor = _this$props2.followCursor,
        getTooltipRef = _this$props2.getTooltipRef;
    var _this$context = this.context,
        parentOutsideClickHandler = _this$context.parentOutsideClickHandler,
        addParentOutsideClickHandler = _this$context.addParentOutsideClickHandler,
        removeParentOutsideClickHandler = _this$context.removeParentOutsideClickHandler,
        parentOutsideRightClickHandler = _this$context.parentOutsideRightClickHandler,
        addParentOutsideRightClickHandler = _this$context.addParentOutsideRightClickHandler,
        removeParentOutsideRightClickHandler = _this$context.removeParentOutsideRightClickHandler;
    var popper = React.createElement(Popper, {
      innerRef: getTooltipRef,
      placement: placement,
      modifiers: _extends({}, DEFAULT_MODIFIERS, modifiers)
    }, function (_ref4) {
      var ref = _ref4.ref,
          style = _ref4.style,
          placement = _ref4.placement,
          arrowProps = _ref4.arrowProps,
          outOfBoundaries = _ref4.outOfBoundaries,
          scheduleUpdate = _ref4.scheduleUpdate;

      if (followCursor) {
        var _this2$state = _this2.state,
            pageX = _this2$state.pageX,
            pageY = _this2$state.pageY;
        style.transform = "translate3d(" + pageX + "px, " + pageY + "px, 0";
      }

      return React.createElement(Tooltip, _extends({
        addParentOutsideClickHandler: addParentOutsideClickHandler,
        addParentOutsideRightClickHandler: addParentOutsideRightClickHandler,
        arrowProps: arrowProps,
        closeOnOutOfBoundaries: closeOnOutOfBoundaries,
        outOfBoundaries: outOfBoundaries,
        parentOutsideClickHandler: parentOutsideClickHandler,
        parentOutsideRightClickHandler: parentOutsideRightClickHandler,
        placement: placement,
        removeParentOutsideClickHandler: removeParentOutsideClickHandler,
        removeParentOutsideRightClickHandler: removeParentOutsideRightClickHandler,
        scheduleUpdate: scheduleUpdate,
        style: style,
        tooltip: tooltip,
        trigger: trigger
      }, {
        clearScheduled: _this2.clearScheduled,
        hideTooltip: _this2.hideTooltip,
        innerRef: ref
      }));
    });
    return React.createElement(Manager, null, React.createElement(Reference, {
      innerRef: getTriggerRef
    }, function (_ref5) {
      var ref = _ref5.ref;
      return children({
        getTriggerProps: _this2.getTriggerProps,
        triggerRef: ref
      });
    }), this.getState() && (usePortal ? createPortal(popper, portalContainer) : popper));
  };

  _proto.isControlled = function isControlled() {
    return this.props.tooltipShown !== undefined;
  };

  _proto.getState = function getState() {
    return this.isControlled() ? this.props.tooltipShown : this.state.tooltipShown;
  };

  return TooltipTrigger;
}(Component);

TooltipTrigger.defaultProps = {
  closeOnOutOfBoundaries: true,
  defaultTooltipShown: false,
  delayHide: 0,
  delayShow: 0,
  followCursor: false,
  onVisibilityChange: noop,
  placement: 'right',
  portalContainer: canUseDOM() ? document.body : null,
  trigger: 'hover',
  usePortal: canUseDOM()
};
TooltipTrigger.contextType = TooltipContext;

export default TooltipTrigger;
//# sourceMappingURL=react-popper-tooltip.js.map
